You have created a set of services that implement the same API, but depending on the source (i.e. where the data is read from), it implements different business logic. 
How would you do this considering the Liskov Substitution principle?

Make the caller unaware of the reader they are using. In fact abstract the reader through an abstract Reader class
from which the other classes are derived and only read through the abstracted memthods.


factory method
- helper:
  class ShapeType(Enum) # self-documenting
  class ShapeContext # container store to hold factory parameters
- main
  class Shape(ABC) # abstract class
  class ShapeFactory # create concret classes
  class Circle(Shape) # concret class
  class Rectangle(Shape) # concret class
